electric vehicle driving and charging situation
{"Objects Definition": [{"name": "EV", "states": [{"name": "SOC", "description": "soc when trip starts #default"}, {"name": "range_fe", "description": "meter"}, {"name": "agent_type", "description": "distinguish agent's type"}, {"name": "fuel_consumption", "description": "default"}, {"name": "remaining_range", "description": "range*soc/100  /meter"}, {"name": "origin", "description": "trip origin #default #osmid id"}, {"name": "charging_start", "description": "a list to collect charging start time/ soc/ station"}, {"name": "prob_charging", "description": "probability of charging"}, {"name": "charge_decision_time", "description": "record time until 10 min"}, {"name": "find_next_charging_station", "description": "in case of always find the next station during wating"}, {"name": "target", "description": "current destination, may change to station: igraph ID"}, {"name": "route", "description": "route"}, {"name": "route_index", "description": "Defined on which road"}, {"name": "currentRoad", "description": "define current road index"}, {"name": "distance_along_edge", "description": "If it's halfway to the edge"}, {"name": "pos_igraph_id", "description": "Location on the path: igraph id"}, {"name": "station_nodes", "description": "inherit all station from model #osimid table"}, {"name": "stations", "description": "igraph id"}, {"name": "finised_time", "description": "finished time: arrive or stranded"}, {"name": "charge_station", "description": "igraph ID"}, {"name": "current_station", "description": "agent object"}, {"name": "status", "description": "driving, finished, stranded, to_charge, charge, wait"}, {"name": "veh_speed", "description": "km/h"}, {"name": "connector_code", "description": "1/3 chademo\uff0c2/3 combo\uff1b#default #need to update"}, {"name": "pos", "description": ""}, {"name": "lat", "description": ""}, {"name": "lon", "description": ""}, {"name": "timestart", "description": ""}, {"name": "capacity", "description": ""}, {"name": "charging_start_soc", "description": ""}, {"name": "charging_end_soc", "description": ""}, {"name": "destination", "description": ""}, {"name": "capacity", "description": ""}, {"name": "pos", "description": ""}, {"name": "distance_travelled", "description": ""}, {"name": "destination_igraph_id", "description": ""}, {"name": "model", "description": ""}, {"name": "destination", "description": ""}, {"name": "destination_igraph_id", "description": ""}, {"name": "trip_distance", "description": ""}, {"name": "model", "description": ""}, {"name": "model", "description": ""}, {"name": "model", "description": ""}, {"name": "model", "description": ""}], "interactions & activities": [{"name": "update_location", "description": "update when driving"}, {"name": "update_route", "description": " Find the shortest path on the graph between the EV and the target, this should happen only once when the trip starts and then the vehicle will traverse on this path happen when trip starts happen when charging station make sense happen when charging end PATH returns a lst of igraph node id"}, {"name": "update_station", "description": " Find nearest station Unresolved problem with the site at the rear Now I use finding charging stations with the shortest distance. The amount of calculation is large. we should find charging stations that are 10km (or less) along the road distance = distance from current location to charging station + distance from charging station to destination stations = [self.model.nodes.index.get_loc(node) for node in self.station_nodes.values] find distances from current postion to all stations by dijkstra method"}, {"name": "find_next_station", "description": " when current station is full, find next station return distance between current pos to next station"}, {"name": "finish", "description": ""}, {"name": "distance_to_next_node", "description": "Finds the distance to the next node along the route"}, {"name": "update_status", "description": " as long as as the vehicle is approaching the target, the SOC should be updated"}, {"name": "charge", "description": "charge status update SOC and station energe consumption"}, {"name": "update_station_object_agent", "description": " turn igraph ID to osmid ID and find the station information"}, {"name": "charge_makes_sense", "description": " This is where we integrate Yan's CCDM (GE Y. Discrete Choice Modeling of Plug-in Electric Vehicle Use and Charging Behavior Using Stated Preference Data[D].2019.) charge will make sense depending on following factors: SOC, time_in_car, charging_cost,  charging_time, access_time, amenity_level (?), deviation(?) Considering SDCM4 cofficients"}, {"name": "distance_to_des", "description": "return distance between current position to the destination"}, {"name": "move", "description": " calculate travelling distance in a step"}, {"name": "status_switch", "description": " fsm"}, {"name": "step", "description": " refresh current location, status, and charges nearby"}]}, {"name": "station", "states": [{"name": "max_power", "description": "current"}, {"name": "timestart", "description": "always"}, {"name": "charge_station", "description": "igraph ID"}, {"name": "dcfc_count", "description": ""}, {"name": "dcfc_var_charging_price_unit", "description": ""}, {"name": "dcfc_fixed_charging_price", "description": ""}, {"name": "dcfc_var_charging_price", "description": ""}, {"name": "dcfc_fixed_parking_price", "description": ""}, {"name": "dcfc_var_parking_price", "description": ""}, {"name": "dcfc_var_parking_price_unit", "description": ""}, {"name": "agent_type", "description": ""}, {"name": "plugs_in_use", "description": ""}, {"name": "waiting_evs_count", "description": ""}, {"name": "restaurents", "description": ""}, {"name": "current_power_draw", "description": ""}, {"name": "queued_evs", "description": ""}, {"name": "igraph_index", "description": ""}, {"name": "energy_consumed", "description": ""}, {"name": "lat", "description": ""}, {"name": "lon", "description": ""}, {"name": "status", "description": ""}, {"name": "veh_speed", "description": ""}, {"name": "SOC", "description": ""}, {"name": "distance_travelled", "description": ""}, {"name": "remaining_range", "description": ""}, {"name": "route_index", "description": ""}], "interactions & activities": [{"name": "step", "description": " stay"}]}, {"name": "SmartScheduler", "states": [{"name": "model", "description": ""}, {"name": "steps", "description": ""}, {"name": "time", "description": ""}, {"name": "_agents", "description": ""}], "interactions & activities": [{"name": "add", "description": ""}, {"name": "remove", "description": "Remove all instances of a given agent from the schedule. Args: agent: An agent object."}, {"name": "step", "description": ""}, {"name": "get_agent_count", "description": " Returns the current number of agents in the queue. "}, {"name": "agent_buffer", "description": "Simple generator that yields the agents while letting the user remove and/or add agents during stepping."}]}, {"name": "EVModel", "states": [{"name": "steptime", "description": "60 seconds refresh  once"}, {"name": "grid", "description": "osmid = self.pos"}, {"name": "_seed", "description": ""}, {"name": "schedule", "description": ""}, {"name": "igraph", "description": ""}, {"name": "nodes", "description": ""}, {"name": "network", "description": ""}, {"name": "station_nodes", "description": ""}, {"name": "network", "description": ""}, {"name": "pos", "description": ""}, {"name": "data_collector", "description": ""}, {"name": "next_id", "description": ""}, {"name": "schedule", "description": ""}, {"name": "next_id", "description": ""}, {"name": "schedule", "description": ""}], "interactions & activities": [{"name": "step", "description": "Advances the model by one step and then stores the current state in data_collector"}, {"name": "run", "description": "Runs the model for the given number of steps` Args: steps: number of steps to run the model for Returns: DataFrame: the agent vars dataframe"}]}], "Functions": [], "Simulation & Schedules": {"name":"simulation","description":"electric vehicle driving and charging situation"}, "Example Usage": ""}
